{
  "GUID": "131f08",
  "Name": "Custom_Model",
  "Transform": {
    "posX": 0.220737338,
    "posY": 1.089999,
    "posZ": -12.1794987,
    "rotX": 7.265914e-7,
    "rotY": 179.994675,
    "rotZ": -1.00011192e-7,
    "scaleX": 2.59999871,
    "scaleY": 2.59999871,
    "scaleZ": 2.59999871
  },
  "Nickname": "Click Roller Strip - Classic",
  "Description": "",
  "GMNotes": "",
  "AltLookAngle": {
    "x": 0,
    "y": 0,
    "z": 0
  },
  "ColorDiffuse": {
    "r": 1,
    "g": 1,
    "b": 1
  },
  "LayoutGroupSortIndex": 0,
  "Value": 0,
  "Locked": true,
  "Grid": true,
  "Snap": true,
  "IgnoreFoW": false,
  "MeasureMovement": false,
  "DragSelectable": true,
  "Autoraise": true,
  "Sticky": true,
  "Tooltip": true,
  "GridProjection": false,
  "HideWhenFaceDown": false,
  "Hands": false,
  "CustomMesh": {
    "MeshURL": "http://cloud-3.steamusercontent.com/ugc/868484544798475589/8077E5F39EAF92E857A504A68FE5A9199130CDF7/",
    "DiffuseURL": "http://cloud-3.steamusercontent.com/ugc/868484544798475860/A6AC97B095F960F2E6672F139E5B48651CBA4094/",
    "NormalURL": "",
    "ColliderURL": "",
    "Convex": true,
    "MaterialIndex": 2,
    "TypeIndex": 0,
    "CustomShader": {
      "SpecularColor": {
        "r": 1,
        "g": 1,
        "b": 1
      },
      "SpecularIntensity": 0,
      "SpecularSharpness": 2,
      "FresnelStrength": 0
    },
    "CastShadows": true
  },
  "LuaScript": "--Dice Clicker Strip by MrStump\r\n--You may edit the below variables to change some of the tool's functionality\r\n\r\n--By default, this tool can roll 6 different dice types (d4-d20)\r\n--If you put a url into the quotes, you can replace a die with a custom_dice\r\n--If you put a name into the quotes, you can replace the default naming\r\n--Changing the number of sides will make the tool's images not match (obviously)\r\n--Only supports custom_dice, not custom models or asset bundles\r\nref_diceCustom = {\r\n    {url=\"http://i.imgur.com/j8d8zPz.png\", name=\"d4\", sides=4},  --Default: d4\r\n    {url=\"http://i.imgur.com/fjtV3gw.png\", name=\"d6\", sides=6},  --Default: d6\r\n    {url=\"http://i.imgur.com/SzI0xzA.png\", name=\"d8\", sides=8},  --Default: d8\r\n    {url=\"http://i.imgur.com/lEeZ1kp.png\", name=\"d10\", sides=10}, --Default: d10\r\n    {url=\"http://i.imgur.com/F3wQ9SQ.png\", name=\"d12\", sides=12}, --Default: d12\r\n    {url=\"http://i.imgur.com/iv6sfnr.png\", name=\"d20\", sides=20}, --Default: d20\r\n}\r\n--Note: Names on dice will overwrite default die naming \"d4, d6, d8, etc\"\r\n\r\n--Should the results be public to everyone\r\nbroadcast_to_self_only = false\r\n\r\n--Chooses what color dice that are rolled are. Options:\r\n    --\"default\" = dice are default tint (recommended)\r\n    --\"player\" = dice are tinted to match he color of player who clicked\r\n    --\"tool\" = dice are tinted to match the color of this tool\r\ndieColor = \"player\"\r\n\r\n--Time before dice disappear. -1 means they do not (until next roll)\r\nremovalDelay = 5\r\n\r\n--Distance dice are placed from the tool's center\r\ndistanceOffset = 2.2\r\n--Length of line dice will be spawned in\r\nwidthMaximum = 7\r\n--Distance die gets moved up off the table when spawned\r\nheightOffset = 2\r\n--Die scale, default of 1 (2 is twice the size, 0.5 is half the size)\r\ndiceScale = {\r\n    1, --d4\r\n    1, --d6\r\n    1, --d8\r\n    1, --d10\r\n    1, --d12\r\n    1, --d20\r\n}\r\n\r\n--How long to wait in seconds before rolling the spawned dice after a click\r\nwaitBeforeRoll = 1.8\r\n\r\n--How long to wait in seconds before rerolling the aced die\r\nwaitBeforeExplodingDie = 2\r\n\r\n--How many dice can be spawned. 0 is infinite\r\ndieLimit = 10\r\n\r\n--END OF VARIABLES TO EDIT WITHOUT SCRIPTING KNOWLEDGE\r\n\r\n\r\n\r\n--Startup\r\n\r\n\r\n\r\n--Save to track currently active dice for disposal on load\r\nfunction onSave()\r\n    if #currentDice > 0 then\r\n        local currentDiceGUIDs = {}\r\n        for _, obj in ipairs(currentDice) do\r\n            if obj ~= nil then\r\n                table.insert(currentDiceGUIDs, obj.getGUID())\r\n            end\r\n        end\r\n        saved_data = JSON.encode(currentDiceGUIDs)\r\n    else\r\n        saved_data = \"\"\r\n    end\r\n    saved_data = \"\"\r\n    return saved_data\r\nend\r\n\r\nfunction onload(saved_data)\r\n    --Loads the save of any active dice and deletes them\r\n    if saved_data ~= \"\" then\r\n        local loaded_data = JSON.decode(saved_data)\r\n        for _, guid in ipairs(loaded_data) do\r\n            local obj = getObjectFromGUID(guid)\r\n            if obj ~= nil then\r\n                destroyObject(obj)\r\n            end\r\n        end\r\n        currentDice = {}\r\n    else\r\n        currentDice = {}\r\n    end\r\n\r\n    cleanupDice()\r\n    spawnRollButtons()\r\n    currentDice = {}\r\nend\r\n\r\n\r\n\r\n--Button clicked to start rolling process (or add to it)\r\n\r\nwild_die_spawned = false\r\nace_dice_results = {}\r\naced_wild_die_results = {}\r\n\r\n--Activated by click\r\nfunction click_roll(color, dieIndex)\r\n    --Dice spam protection, can be disabled up at top of script\r\n    local diceCount = 0\r\n    for _ in pairs(currentDice) do\r\n        diceCount = diceCount + 1\r\n    end\r\n    local denyRoll = false\r\n    if dieLimit > 0 and diceCount >= dieLimit then\r\n        denyRoll = true\r\n    end\r\n    if ref_diceCustom[dieIndex].name == \"Wild Die\" and wild_die_spawned == true then\r\n        denyRoll = true\r\n    end\r\n    \r\n    --Check for if click is allowed\r\n    if rollInProgress == nil and denyRoll == false then\r\n        \r\n        -- clear any previous rolls\r\n        ace_dice_results = {}\r\n        aced_wild_die_results = {}\r\n        \r\n        --Find dice positions, moving previously spawned dice if needed\r\n        local angleStep = 360 / (#currentDice+1)\r\n        for i, die in ipairs(currentDice) do\r\n            die.setPositionSmooth(getPositionInLine(i), false, true)\r\n        end\r\n\r\n        --Determines type of die to spawn (custom or not, number of sides)\r\n        local spawn_type = \"Custom_Dice\"\r\n        local spawn_sides = ref_diceCustom[dieIndex].sides\r\n        local spawn_scale = diceScale[dieIndex]\r\n        if ref_diceCustom[dieIndex].url == \"\" then\r\n            spawn_type = ref_defaultDieSides[dieIndex]\r\n        end\r\n\r\n        --Spawns that die\r\n        local spawn_pos = getPositionInLine(#currentDice+1)\r\n        local spawnedDie = spawnObject({\r\n            type=spawn_type,\r\n            position = spawn_pos,\r\n            rotation = randomRotation(),\r\n            scale={spawn_scale,spawn_scale,spawn_scale}\r\n        })\r\n        if spawn_type == \"Custom_Dice\" then\r\n            spawnedDie.setCustomObject({\r\n                image = ref_diceCustom[dieIndex].url,\r\n                type = ref_customDieSides[tostring(spawn_sides)]\r\n            })\r\n        end\r\n\r\n        --After die is spawned, actions to take on it\r\n        table.insert(currentDice, spawnedDie)\r\n        spawnedDie.setLock(true)\r\n        if ref_diceCustom[dieIndex].name ~= \"\" then\r\n            spawnedDie.setName(ref_diceCustom[dieIndex].name)\r\n        end\r\n\t\tif dieColor == 'player' then\r\n\t\t\tspawnedDie.setColorTint(Color.fromString(color))\r\n\t\telseif dieColor == 'tool' then\r\n\t\t\tspawnedDie.setColorTint(self.getColorTint())\r\n\t\tend\r\n\r\n        --Timer starting\r\n        Timer.destroy(\"clickRoller_\"..self.getGUID())\r\n        Timer.create({\r\n            identifier=\"clickRoller_\"..self.getGUID(), delay=waitBeforeRoll,\r\n            function_name=\"rollDice\", function_owner=self,\r\n            parameters = {color = color}\r\n        })\r\n    elseif rollInProgress == false then\r\n        cleanupDice()\r\n        click_roll(color, dieIndex)\r\n    elseif denyRoll == true and wild_die_spawned == true then\r\n        Player[color].broadcast(\"Only 1 Wild Die can be rolled at a time.\")\r\n    else\r\n        Player[color].broadcast(\"Roll in progress.\", {0.8, 0.2, 0.2})\r\n    end\r\nend\r\n\r\n\r\n\r\n--Die rolling\r\n\r\n\r\n\r\n--Rolls all the dice and then launches monitoring\r\nfunction rollDice(p)\r\n    rollInProgress = true\r\n    function coroutine_rollDice()\r\n        for _, die in ipairs(currentDice) do\r\n            doRoll(die)\r\n        end\r\n\r\n        monitorDice(p.color)\r\n\r\n        return 1\r\n    end\r\n    startLuaCoroutine(self, \"coroutine_rollDice\")\r\nend\r\n\r\nfunction doRoll(die)\r\n    die.setLock(false)\r\n    die.setRotation(randomRotation())\r\n    for i = 1, 4, 1 do\r\n        die.randomize()\r\n        die.roll()\r\n    end\r\n    die.roll()\r\n    wait(0.1)\r\nend\r\n\r\n--Monitors dice to come to rest\r\nfunction monitorDice(color)\r\n    function coroutine_monitorDice()\r\n        repeat\r\n            local allRest = true\r\n            for _, die in ipairs(currentDice) do\r\n                if die ~= nil and die.resting == false then\r\n                    allRest = false\r\n                end\r\n            end\r\n            coroutine.yield(0)\r\n        until allRest == true\r\n\r\n        -- Flash Aces (Savage Worlds)\r\n        local flashing = false\r\n        for _, die in ipairs(currentDice) do\r\n            if die ~= nil then\r\n                --Tally value info\r\n                local guid = die.getGUID()\r\n                local value = die.getValue()\r\n                \r\n                -- ace_dice_results = {}\r\n                local rv = die.getRotationValues()\r\n                if value == rv[#rv].value then\r\n                    flash(die)\r\n                    flashing = true\r\n                    local newDie = true\r\n                    for i, v in ipairs(ace_dice_results) do\r\n                        if v.die == guid then\r\n                            newDie = false\r\n                            v.value = v.value + value\r\n                        end\r\n                    end\r\n                    if newDie and die.name ~= \"Wild Die\" then\r\n                        table.insert(ace_dice_results, {value=value, die=guid})\r\n                    elseif newDie and die.name == \"Wild Die\" then\r\n                        table.insert(aced_wild_die_results, {value=value, die=guid})\r\n                    end\r\n                end\r\n            end\r\n        end\r\n        \r\n        if flashing then\r\n            wait(waitBeforeExplodingDie) -- Flash a few seconds then reroll\r\n        end\r\n        \r\n        -- Reroll Aces (Savage Worlds)\r\n        local rerolling = false\r\n        for _, die in ipairs(currentDice) do\r\n            if die ~= nil then\r\n                --Tally value info\r\n                local value = die.getValue()\r\n                local rv = die.getRotationValues()\r\n                if value == rv[#rv].value then\r\n                    doRoll(die)\r\n                    rerolling = true\r\n                end\r\n            end\r\n        end\r\n        \r\n        if rerolling then\r\n            monitorDice(color)\r\n        else\r\n            for _, die in ipairs(currentDice) do\r\n                if die ~= nil then\r\n                    --Tally value info\r\n                    local guid = die.getGUID()\r\n                    local value = die.getValue()\r\n                    local newDie = true\r\n                    for i, v in ipairs(ace_dice_results) do\r\n                        if v.die == guid then\r\n                            newDie = false\r\n                            v.value = v.value + value\r\n                        end\r\n                    end\r\n                    if newDie and die.name ~= \"Wild Die\" then\r\n                        table.insert(ace_dice_results, {value=value, die=guid})\r\n                    elseif newDie and die.name == \"Wild Die\" then\r\n                        table.insert(aced_wild_die_results, {value=value, die=guid})\r\n                    end\r\n                end\r\n            end\r\n            --Announcement\r\n            displayHighest(color) \r\n        end\r\n\r\n        wait(0.1)\r\n        rollInProgress = false\r\n\r\n        --Auto die removal\r\n        if removalDelay ~= -1 then\r\n            --Timer starting\r\n            Timer.destroy(\"clickRoller_cleanup_\"..self.getGUID())\r\n            Timer.create({\r\n                identifier=\"clickRoller_cleanup_\"..self.getGUID(),\r\n                function_name=\"cleanupDice\", function_owner=self,\r\n                delay=removalDelay,\r\n            })\r\n        end\r\n\r\n        return 1\r\n    end\r\n    startLuaCoroutine(self, \"coroutine_monitorDice\")\r\nend\r\n\r\n\r\n\r\n--After roll broadcasting\r\nfunction displayHighest(color)\r\n    --detect dmg rolls\r\n    if wild_die_spawned == true then\r\n        local total = 0\r\n        for _, die in ipairs(ace_dice_results) do\r\n            if die ~= nil then\r\n                --Tally value info\r\n                local value = die.value\r\n                total = total + value\r\n            end\r\n        end\r\n        broadcast(Player[color].steam_name .. \" rolled damage of \" .. total, color, {1,1,1})\r\n    else\r\n        --detect critical fails\r\n        \r\n        --Combine our tables to find the final highest result(s)\r\n        for k,v in pairs(aced_wild_die_results) do ace_dice_results[k] = v end\r\n        \r\n        local sort_func = function(a,b) return a.value > b.value end\r\n        table.sort(ace_dice_results, sort_func)\r\n        \r\n        -- This needs work, criitcal is when more then half dice fail when rolling more and must have a wild die failure!\r\n        local fails = {}\r\n        for i, v in ipairs(ace_dice_results) do\r\n            if v.value == 1 then\r\n                table.insert(fails, {1})\r\n            end\r\n        end\r\n        local critical_fail = false\r\n        local numberOfDice = tablelength(ace_dice_results)\r\n        local numberOfFails = tablelength(fails)\r\n        if numberOfDice/2 < numberOfFails then\r\n            broadcast(Player[color].steam_name .. \" went Bust! Final Result: \" .. ace_dice_results[1].value, color, Color.Red)\r\n        else\r\n            broadcast(Player[color].steam_name .. \" rolled: \" .. ace_dice_results[1].value, color, {1, 1, 1})\r\n        end\r\n    end\r\nend\r\n\r\nfunction tablelength(T)\r\n  local count = 0\r\n  for _ in pairs(T) do count = count + 1 end\r\n  return count\r\nend\r\n\r\n--Die cleanup\r\n\r\n\r\n\r\nfunction cleanupDice()\r\n    for _, die in ipairs(currentDice) do\r\n        if die ~= nil then\r\n            destroyObject(die)\r\n        end\r\n    end\r\n\r\n    Timer.destroy(\"clickRoller_cleanup_\"..self.getGUID())\r\n    rollInProgress = nil\r\n    currentDice = {}\r\n    ace_dice_results = {}\r\n    wild_die_spawned = false\r\nend\r\n\r\n\r\n\r\n--Utility functions\r\n\r\nfunction broadcast(s, p_color, s_color)\r\n    if broadcast_to_self_only == true then\r\n        broadcastToSelf(s, p_color, s_color)\r\n    else\r\n        broadcastToAll(s, s_color)  \r\n    end\r\nend\r\n\r\nfunction broadcastToSelf(s, p_color, s_color)\r\n    broadcastToColor(\"[Hidden] - \" .. s, p_color, s_color)\r\nend\r\n\r\n--Return a position based on relative position on a line\r\nfunction getPositionInLine(i)\r\n    local totalDice = #currentDice + 3\r\n    local totalWidth = widthMaximum\r\n    --Change total width here maybe\r\n    local widthStep = widthMaximum / (totalDice-1)\r\n    local x = -widthStep * i + (widthMaximum/2)\r\n    local y = heightOffset\r\n    local z = -distanceOffset\r\n    return self.positionToWorld({x,y,z})\r\nend\r\n\r\n--Gets a random rotation vector\r\nfunction randomRotation()\r\n    --Credit for this function goes to Revinor (forums)\r\n    --Get 3 random numbers\r\n    local u1 = math.random();\r\n    local u2 = math.random();\r\n    local u3 = math.random();\r\n    --Convert them into quats to avoid gimbal lock\r\n    local u1sqrt = math.sqrt(u1);\r\n    local u1m1sqrt = math.sqrt(1-u1);\r\n    local qx = u1m1sqrt *math.sin(2*math.pi*u2);\r\n    local qy = u1m1sqrt *math.cos(2*math.pi*u2);\r\n    local qz = u1sqrt *math.sin(2*math.pi*u3);\r\n    local qw = u1sqrt *math.cos(2*math.pi*u3);\r\n    --Apply rotation\r\n    local ysqr = qy * qy;\r\n    local t0 = -2.0 * (ysqr + qz * qz) + 1.0;\r\n    local t1 = 2.0 * (qx * qy - qw * qz);\r\n    local t2 = -2.0 * (qx * qz + qw * qy);\r\n    local t3 = 2.0 * (qy * qz - qw * qx);\r\n    local t4 = -2.0 * (qx * qx + ysqr) + 1.0;\r\n    --Correct\r\n    if t2 > 1.0 then t2 = 1.0 end\r\n    if t2 < -1.0 then ts = -1.0 end\r\n    --Convert back to X/Y/Z\r\n    local xr = math.asin(t2);\r\n    local yr = math.atan2(t3, t4);\r\n    local zr = math.atan2(t1, t0);\r\n    --Return result\r\n    return {math.deg(xr),math.deg(yr),math.deg(zr)}\r\nend\r\n\r\n--Coroutine delay, in seconds\r\nfunction wait(time)\r\n    local start = os.time()\r\n    repeat coroutine.yield(0) until os.time() > start + time\r\nend\r\n\r\n--Turns an RGB table into hex\r\nfunction RGBToHex(rgb)\r\n    if rgb ~= nil then\r\n        return \"[\" .. string.format(\"%02x%02x%02x\", rgb[1]*255,rgb[2]*255,rgb[3]*255) .. \"]\"\r\n    else\r\n        return \"\"\r\n    end\r\nend\r\n\r\n\r\n\r\n--Button creation\r\n\r\n\r\n\r\nfunction spawnRollButtons()\r\n    for i, entry in ipairs(ref_diceCustom) do\r\n        local funcName = \"button_\"..i\r\n        local func = function(_, c) click_roll(c, i) end\r\n        self.setVar(funcName, func)\r\n        self.createButton({\r\n            click_function=funcName, function_owner=self, color={1,1,1,0},\r\n            position={-2.5+(i-1)*1,0.05,0}, height=330, width=330\r\n        })\r\n    end\r\nend\r\n\r\n-- Flash Dice when rolling max\r\n\r\nfunction flash(d, g)\r\n    if not getObjectFromGUID(d.guid) or g and g > 20 then\r\n        return false\r\n    end\r\n    local a = g or 1\r\n    local h = self.getColorTint()\r\n    if a % 2 == 0 then\r\n        h = randomColor()\r\n    end\r\n    if d.tag == \"3D Text\" then\r\n        d.TextTool.setFontColor(h)\r\n    else\r\n        d.highlightOn(h, 0.1)\r\n    end\r\n    Wait.time(\r\n        function()\r\n            flash(d, a + 1)\r\n        end,\r\n        0.2\r\n    )\r\nend\r\nfunction randomColor()\r\n    local i = math.random\r\n    return {i(255) / 255, i(255) / 255, i(255) / 255}\r\nend\r\n\r\n--Data tables\r\n\r\nref_customDieSides = {[\"4\"]=0, [\"6\"]=1, [\"8\"]=2, [\"10\"]=3, [\"12\"]=4, [\"20\"]=5}\r\n\r\nref_customDieSides_rev = {4,6,8,10,12,20}\r\n\r\nref_defaultDieSides = {\"Die_4\", \"Die_6\", \"Die_8\", \"Die_10\", \"Die_12\", \"Die_20\"}\r\n",
  "LuaScriptState": "",
  "XmlUI": ""
}